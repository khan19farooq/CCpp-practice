                                    -----NULL pointers-----
In programming, NULL pointers are pointers which do not point to any memory location. 
They are used to indicate that the pointer does not refer to a valid object or memory location.
Some of the common uses of NULL pointers are:

1. Initialization: When we declare a pointer variable but do not have a valid memory address to 
assign to it initially, we can set it NULL to indicate that its not pointing to any 
valid memory address.

2. Error Handling: NULL pointer are often used to indicate errors or exceptional conditions in  
programs.For example, if a function fails to allocate memory or encounters an error conditon, 
it may return a NULL pointer to indicate the failure.

3. Termination Condition: In data structures like linked lists and tress, 
NULL pointers are commonly used to mark the end of a list on the absence of a child node.
This allows you to easily traverse the data structures and know when you have reached the end. 

4. Memory deallocation: After freeing memory allocated to pointer using functions like free() in languages 
like C or C++, it is good practice to set the pointer to NULL to avoid potential issues with 
accessing memory that has been deallocated.

5. Checking for validity: Before dereferencing a pointer, it is good practice to check if it is NULL 
to avoid accessing invalid memory locations, which can lead to program crashes or undefined behavior. 

Overall, NULL pointers play a crucial role in indicating the absence of valid memory locations and 
are commonly used for error handling, initialization, termination conditions, memory allocation, 
and checking for validity in programming languages like C C++ and others that work with pointers.
------------------------------------------------------------------------------------------------------

Q.1 What is the size of the integer, character, double and float?
Ans Size of int:    4 bytes (earlier it was 2 bytes in the previous architecture)
    Size of float:  4 bytes
    Size of double: 8 bytes
    Size of char:   1 byte
-------------------------------------------------------------------------------------------------------
Q.2 What is the size of the pointer? What is the size of the integer pointer, float pointer 
    and character pointer?
Ans Size of the pointer is consistent for any data type. Pointer is a holder to hold the address.
    However, it varies with the architecture.
    4 bytes is the size of the pointer for 32 bit architecture.
    8 bytes is the size of the pointer for 64 bit architecture.
-------------------------------------------------------------------------------------------------------
Q.3 What is a pointer?
Ans It is a holder to hold the address. A pointer is really just a variable that contains an address.
    Remember, it is a variable.
    Pointer is just like any other variable which has a type. Means, a pointer can be an integer pointer
    or float pointer. (It has to hold an address, but address of some type of variable)
-------------------------------------------------------------------------------------------------------
Q.4 What is a NULL pointer?
Ans A NULL pointer is a special pointer that points to nowhere. That is no other pointer will be 
    equal to Null pointer.
    The most easier and straight forward way to get a NULL pointer in your program is to use the 
    predefined constant NULL, which is defined by several header files including <stdio.h> <stdlib.h>
    and <string.h>

    The NULL is a macro defined in C. NULL pointer actually means a pointer that does not point to any
    valid location. We define a pointer to be NULL when we want to make sure that the pointer does not
    point to any valid location and not to use that pointer to change anything. If we do not use NULL
    pointer, then we cannot verify whether this pointer points to any valid location or not.

    Example: // NULL pointer

    #include <stdio.h>

    int main()
    {
        int *p;
        p = NULL;

        printf("\n The value of P is %u", p);

        return 0;
    }

    output:
    The value of P is 0
-------------------------------------------------------------------------------------------------------
Q.5 What is a void pointer? What is its limitation?
Ans A void pointer is a special type of pointer. It can point to any data type, from an 
    integer value to float to anything! Its sole limitation is that it can be referenced directly. 
    ('*' cannot be used on them as the length is always undetermined.)
    Therefore, type casting is required and must be used to turn the void pointer to a pointer of a 
    concrete data type to which we can refer. An example would be helpful.

    #include <stdio.h>
    int main()
    {
        int a = 5;
        double b = 3.233;
        void *vp; // void pointer declaration

        vp = &a;
        printf("\n a = %d", *((int*)vp));
        vp = &b;
        printf("\n b = %f", *((double*)vp));

        return 0;
    }

    Output:
    a = 5
    b = 3.233
-------------------------------------------------------------------------------------------------------
Q.6 What is an ISR? (Interrupt Service Routine)
Ans It is an Interrupt Handler. It means, it shall be called the moment an interrupt is encountered.
        An interrupt occurs.
        Immediate reaction is - call the subroutine corresponding to the interrupt.
        That subroutine is called ISR.
    An ISR (Interrupt Service Routine) is an interrupt handler, a callback subroutine which is called
    when a interrupt is encountered.
-------------------------------------------------------------------------------------------------------
Q.7 What is a return type of ISR?
Ans ISR does not return anything. Means, there is no return. Also, there is no one to read the 
    returned value. 
    An ISR returns nothing because there is no caller in the code to read the returned values.
-------------------------------------------------------------------------------------------------------
Q.8 What is Latency? What is interrupt latency?
Ans Latency means delay. Interrupt latency is the time required for the interrupt to be responded.
    i.e. the time required for the ISR to respond to an interrupt.

    Interrupt latency can be minimized by writing short ISR routine and by not delaying interrupts
    for more time.
-------------------------------------------------------------------------------------------------------
Q.9 What is the use of volatile keyword?
Ans The C's volatile keyword is a qualifier that tells the compiler not to optimize when applied
    to a variable. By declaring a variable volatile, we can tell the compiler that the value 
    of the variable may change any moment from outside of the scope of the program. 

    A variable should be declared volatile whenever its value could change unexpectedly and beyond
    the comprehension of the compiler. In those cases it is required not to optimize the code, doing
    so may lead to erroneous result and load the variable every time it is used in the program.

    Volatile keyword is useful for memory mapped peripheral registers, global variables modified by 
    interrupt service routine, global variables accessed by multiple tasks within a multi-threaded 
    application.
-------------------------------------------------------------------------------------------------------
Q.10 Can a variable be both const and volatile?
Ans  The const keywords make sure that the value of the variable declared as const cannot be changed.
     This statement holds true in the scope of the program. The value can still be changed by outside 
     intervention. So, the use of const with volatile makes perfect sense.

     Yes, a variable can be both const and volatile in C. This combination is used in 
     embedded systems programming to represent a read-only hardware register whose value 
     can change unexpectedly, for instance, due to hardware events.

     Explanation
     const: This keyword indicates that the variable is read-only, and its value cannot be 
     modified by the program.
     volatile: This keyword tells the compiler that the value of the variable may change at any time, 
     without any action being taken by the code the compiler finds nearby.
     This prevents the compiler from optimizing the code by assuming the value remains constant.

     Use Case
     A common use case for a const volatile variable is when dealing with hardware registers. 
     For example, a status register that is updated by hardware but should not be modified by 
     the program.

     Example
     Here's an example to illustrate the use of a const volatile variable:

     #include <stdio.h>

     // Assuming the hardware register is located at this address
     #define STATUS_REGISTER ((const volatile uint8_t*)0x40004000)

     int main() {
         // Read the status register
         uint8_t status = *STATUS_REGISTER;

         // Print the status
         printf("Status register value: %u\n", status);

        return 0;
        }
-------------------------------------------------------------------------------------------------------
Q.11 Can a pointer be voltile?
Ans  If wee see the declaration volatile int *p, it means that the pointer itself is not volatile
     and points to an integer that is volatile. This is to inform the compiler that pointer p is 
     pointing to an integer and the value of that integer may change unexpectedly.
-------------------------------------------------------------------------------------------------------
Q.12 Can we use any functions inside ISR?
Ans  We can use functions inside ISR as long as that function is not invoked from other portion of the 
     code.
-------------------------------------------------------------------------------------------------------
Q.13 Can we use printf function inside ISR?
Ans  printf function in ISR is not supported because printf function is not reentrant, thread safe and 
     uses dynamic memory allocation which takes a lot of time and can affect the speed of an ISR up to a 
     great extent.
-------------------------------------------------------------------------------------------------------
Q.14 Can we put breakpoint inside ISR?
Ans  Putting a breakpoint inside ISR is not a good idea because debugging will take some time and a 
     difference of half or more second will lead to different behavior of hardware. 
     To debug ISR, definitive logs are better.
------------------------------------------------------------------------------------------------------- 
Q.15 Can static varible be declared in a header file?
Ans  A static variable cannot be declared without defining it. A static variable can be defined in the 
     header file. But doing so, the result will be having a private copy of that variable in each source 
     file which includes the header file. So it will be wise not to declare a static variable in header file,
     unless you are dealing with a  different scenario.
-------------------------------------------------------------------------------------------------------
Q.16 Is count down to zero loops better than count up loops?
Ans  Count down to zero loops are better. Reason is - at loop termination, comparison to zero can be optimized
     by the compiler. Most processors have instruction for comparing to zero. So they don't need to load the 
     variable and the maximum value, subtract them and then compare to zero. That is why count down to zero loops
     are better.
-------------------------------------------------------------------------------------------------------
Q.17 What is the difference between I2C and SPI communication?
Ans  I2C stands for Inter-Integrated Circuit. I2C is a simple two-wire protocol used to communicate between 
     two devices or chips in an embedded system. I2C has two lines SCL (Serial Clock Line) and 
     SDA (Serial Data Line), SCL is used for clock and SDA is used for data.

     SPI stands for Serial Peripheral Interface. SPI is a four-wire serial communication protocol. SPI follows 
     master-slave architecture. The four lines of SPI are MOSI, MISO, SCL and SS. SCL is a serial clock that is 
     used for entire data communication. Slave Select (SS) is used to select the slave. 
     Master Out Slave In (MOSI) is the output data from the master and Master In Slave Out (MISO) is the 
     input data line for the Master.

     Differences:

     -> I2C is half-duplex communication and SPI is a full-duplex communication.
     -> I2C supports multi-master and multi-slave architecture whereas, SPI supports single-master multiple slaves 
        architecture.
     -> I2C is a two wire protocol and SPI is a four wire protocol.
     -> I2C supports clock stretching and SPI does not have clock stretching.
     -> I2C is slower than SPI.
     -> I2C has an extra overhead start and stop bits and SPI does not have any start and stop bits.
     -> I2C has a pull up resistor requirement.

     Advantages of I2C: Easy device add-on - it is easy to add new device to the bus. Just add the new device 
                        without adding a new slave select, unlike SPI.

     Advantages of SPI: Speed - SPI can support speed upto 10 MB/s however I2C in the ultra fast mode can 
                        support only 5 MB/s.
-------------------------------------------------------------------------------------------------------
Q.18 What are storage classes in C?
Ans  There are 4 storage classes in C: Auto, Static, Extern and Register.
  -> Auto: This is the default storage class for all the variables declared inside a function or a block. 
     Hence, the keyword auto is rarely used while writing programs in C language. Auto variables can be only 
     accessed within the block/function they have been declared and not outside them (which defines their scope). 
     Of course, these can be accessed within nested blocks within the parent block/function in which the 
     auto variable was declared. However, they can be accessed outside their scope as well using the concept of 
     pointers given here by pointing to the very exact memory location where the variables reside. They are 
     assigned a garbage value by default whenever they are declared.  

  -> Static: This storage class is used to declare static variables which are popularly used while writing 
     programs in C language. Static variables have the property of preserving their value even after they are 
     out of their scope! Hence, static variables preserve the value of their last use in their scope. 
     So we can say that they are initialized only once and exist till the termination of the program. 
     Thus, no new memory is allocated because they are not re-declared.

     Their scope is local to the function to which they were defined. Global static variables can be accessed 
     anywhere in the program. By default, they are assigned the value 0 by the compiler. 
     
  -> Extern: Extern storage class simply tells us that the variable is defined elsewhere and not within the 
     same block where it is used. Basically, the value is assigned to it in a different block and this can be 
     overwritten/changed in a different block as well. So an extern variable is nothing but a global variable 
     initialized with a legal value where it is declared in order to be used elsewhere. It can be accessed within 
     any function/block.

     Also, a normal global variable can be made extern as well by placing the ‘extern’ keyword before its 
     declaration/definition in any function/block. This basically signifies that we are not initializing a 
     new variable but instead, we are using/accessing the global variable only. The main purpose of using extern 
     variables is that they can be accessed between two different files which are part of a large program.
     
  -> Register: This storage class declares register variables that have the same functionality as that of the 
     auto variables. The only difference is that the compiler tries to store these variables in the register 
     of the microprocessor if a free register is available. This makes the use of register variables to be much 
     faster than that of the variables stored in the memory during the runtime of the program.

     If a free registration is not available, these are then stored in the memory only. Usually, a few variables 
     which are to be accessed very frequently in a program are declared with the register keyword which improves 
     the running time of the program. An important and interesting point to be noted here is that we cannot 
     obtain the address of a register variable using pointers.

-------------------------------------------------------------------------------------------------------
Q.19 What is a watchdog timer? Why do we need to reset the watchdog timer?
Ans  A watchdog timer(WDT) is a hardware timer used in embedded systems to detect and recover from software 
     malfuncitons. It acts as a safety mechanism that helps ensure the system remains operational, even if the 
     software encounters an error or gets stuck in a infinite loop. 
     How a watchdog timer works:
     1. Initialization: The watchdog timer is configured  to a specific timeout period by the software.
                        This period should be long enough to allow normal operation but short enough to 
                        detect malfuncitons promptly.
     2. Regular Resets: The software must periodically reset the watchdog timer (often called "kicking" or 
                        "feeding" the watchdog) to prevent it from timing out. This reset is typically done 
                        within the main program loop or critical points in the code.
     3. Timeout and Reset: The software must periodically set the watchdog timer within the specified period 
                           (indicating a potential malfunction and software hang), the watchdog timer will time out 
                           and trigger a system reset or other predefined recovery actions.

-------------------------------------------------------------------------------------------------------
Q.20 What is the use of size_t?
Ans  The 'size_t' type in C programming is an unsigned integral type used to represent sizes of objects and 
     is the preferred type for array indexing and loop counters when dealing with sizes and counts that are 
     non-negative. It is defined in the '<stddef.h>' header file and also in '<stdio.h>'.

-------------------------------------------------------------------------------------------------------
                                        MATLAB-Specific Questions

Q.1 How do you define and manipulate matrices in MATLAB?
Ans In MATLAB, matrices can be defined using square brackets. For example, A = [1, 2; 3, 4] creates a 
    2x2 matrix. You can manipulate matrices using operations like addition, subtraction, multiplication, 
    and division. Functions such as transpose(A), inv(A) for inversion, and det(A) for determinant are 
    also commonly used.

-------------------------------------------------------------------------------------------------------
Q.2 Can you explain how to use cell arrays and structures in Matlab?
Ans Cell arrays are used to store data of varying types and sizes. For example, 
    C = {1, 'text', [1, 2, 3]}. You can access cell elements using curly braces, like C{2}. 
    Structures are used to group related data using named fields, e.g., S.name = 'John'; S.age = 30;. 
    Fields are accessed using dot notation, like S.name.

-------------------------------------------------------------------------------------------------------
Q.3 What are the different data types present in Matlab?
Ans MATLAB supports several data types, including:
    Numeric types: double, single, int8, uint8, int16, uint16, int32, uint32, int64, uint64
    Logical type:  logical
    Characters and strings: char, string
    Fixed-point: fi (requires Fixed-Point Designer)
    Complex numbers, cell arrays, structures, function handles, tables, categorical arrays, datetime, 
    duration, and calendarDuration.

-------------------------------------------------------------------------------------------------------
Q.4 How do you handle overflow when multipying an 'uint8_t' value with a single value?
Ans To handle overflow, you can either cast the result back to the desired type with appropriate handling 
    or use fixed-point arithmetic to manage precision and range. For example:
    a = uint8(200);
    b = single(2.5);
    result = a * b;
    result_uint8 = uint8(min(max(result, 0), 255));  % Clamping the result to uint8 range

-------------------------------------------------------------------------------------------------------
Q.5 What is the difference between a function and a script?
Ans A script is a file containing a sequence of Matlab commands that are executed together. It does not
    accept input arguments or return outputs. A function, on the other hand, is defined using 'function' 
    keyword, can accept input arguments and return outputs. Funtions have their own workspace separate 
    base workspace.

-------------------------------------------------------------------------------------------------------
Q.6 How do you create and use anonymous functions in Matlab?
Ans Anonymous functions are defined using the '@' symbol. For example:
    f = @(x) x^2 + 2*x + 1;
    y = f(3);  % Evaluates to 16

-------------------------------------------------------------------------------------------------------
Q.7 Describe how you would implement error handling in Matlab code.
Ans Error handling in MATLAB is implemented using try, catch blocks. For example:
    try
        result = riskyOperation();
    catch ME
        disp('An error occurred');
        disp(ME.message);
    end

-------------------------------------------------------------------------------------------------------
Q.8 How do you optimize the performance of Matlab code?
Ans To optimize MATLAB code, you can:
    -> Preallocate arrays to avoid dynamic resizing.
    -> Use vectorized operations instead of loops.
    -> Use built-in functions, which are often optimized.
    -> Profile the code to identify bottlenecks using the profile function.
    -> Avoid using global variables as they slow down performance.

-------------------------------------------------------------------------------------------------------
Q.9 Explain how you would profile Matlab code to identify performance bottlenecks.
Ans Use the profile function to start profiling, run the code, and then use profile viewer to inspect 
    the results. For example:

    profile on;
    myFunction();
    profile off;
    profile viewer;
-------------------------------------------------------------------------------------------------------
Q.10 What are some commonly used Matlab toolboxes in embedded systems development?
Ans  Some commonly used toolboxes in embedded systems development include:
     Simulink:             For model-based design and simulation.
     Fixed-Point Designer: For designing and simulating fixed-point systems.
     Embedded Coder:       For generating C code from Simulink models.
     Stateflow:            For designing state machines and control logic.
------------------------------------------------------------------------------------------------------- 
Q.11 How do you create and simulate a basic model in simulink?
Ans  In simulink, you create models by dragging and dropping blocks from the Simulink library browser 
     into a model window. Connect the blocks using signal lines to define the flow of data. To simulate 
     the model, configure the simulation parameters and click "Run" button.

------------------------------------------------------------------------------------------------------- 
Q.12 What is model-based development and how it is used in simulink?
Ans  Model based development involves creating a graphical model that represents the system. Simulink 
     is used design, simulate and test these models. This approach allows for early verification and 
     validation and it can automatically generate code for the embedded system.  

------------------------------------------------------------------------------------------------------- 
Q.13 Explain the use of Stateflow tool in Simulink.
Ans  Stateflow is used to design and simulate state machines and control logic. It provides a graphical
     interface for modeling reactive systems, enabling the design of complex logic using states, transitions,
     events and actions.

------------------------------------------------------------------------------------------------------- 
Q.14 How do you perform Hardware-in-Loop (HIL) testing in Simulink?
Ans  HIL testing involves running a real-time simulation of the system on a target hardware platform.
     Simulink models are used to create the simulation, and tools like Simulink Real Time are used to 
     deploy the model to real-time hardware. This allows for testing the control algorithms with real 
     hardware inputs and outputs.

------------------------------------------------------------------------------------------------------- 
Q.15 How do you use Matlab scripts to automate the Simulink simulations?
Ans  Matlab scripts can be used to automate Simulink simulations by using commands like 'sim' to run the
     simulation programmatically. For example:
     
     load_system('myModel');
     sim('myModel');

------------------------------------------------------------------------------------------------------- 
Q.16 What is the role of configuration parameters in Simulink models?
Ans  Configuration parameters in Simulink models define the settings for simulation, code generation and 
     data logging. They control aspects like solver options, optimization settings, hardware implementation
     settings, and data import/export configurations.

-------------------------------------------------------------------------------------------------------
                                        Behavioral Questions

Q.1 Explain your work in DSP in Matlab?
Ans During my Master's program, I took DSP I & II courses and worked on a project titled "Challenges in 
    Signal Processing for Fetal Phonocardiogram". The objective of this project was to reduce the noise 
    in signals from fetal heart sounds and maternal heart sounds. To achieve this, I utilized Matlab and
    Simulink to develop scripts that implemented spectral subtraction and Weiner filtering methods.

    Using Matlab and Simulink's DSP toolboxes, which offer extensive features for signal processing, 
    I was able to create a robust algorithm that effectively reduced noise and provided clear output 
    results. This experience underscored the power and versalitity of Matlab and Simulink in handling 
    complex signal and system challenges.

    Recently, I worked on reducing noise in ADC (Analog to Digital converter) signals using digital 
    signal processing (DSP) techniques. ADC signals often contain noise that can interfere with the
    accuracy and reliability of the data being processed. To address this, I employed various filtering 
    methods to clean the signals and enhance their quality.

-------------------------------------------------------------------------------------------------------
Q.2 Introduce yourself.
Ans Hello my name is Farooq Khan. I recently worked as an Embedded Software Engineer at Baxter's 
    Batesville R&D facility, where I gained over four years of experience in the medical device industry.
    My background includes developing and testing embedded software for various medical devices, ensuring
    compliance with regulatory standards like FDA and IEC 62304, and collaborating with cross-functional 
    teams to deliver high-quality products.

    At Baxter, I was responsible for product verification testing, root cause analysis, and developing 
    software for drive control systems, among other tasks.Unfortuantely, due to a company-wide 
    restructuring, my position was impacted, and I was laid off. However, this has given me an opportunity  
    to seek new challenges and bring my expertise to a new organization.

    I am particularly excited about this role at Cummins because of your commitment to innovation and 
    quality, which aligns with my professional values and  experience. I am eager to contribute my skills 
    in Embedded systems and problem-solving to help drive your projects forward and deliver outstanding 
    results.

-------------------------------------------------------------------------------------------------------
Q.3 How do you solve a problem?
Ans I approach problem-solving systematically by following a structured process that involves understanding
    the problem, analyzing the possible causes, brainstorming potential solutions, implementing the best 
    solution, and reviewing the results.

    For example, in one of my recent projects, we encountered a critical issue with the drive control
    board on a medical bed that was causing inconsistent motor speeds, potentially compromising patient
    safety. Here's how I addressed the problem:

    1. Understand the problem: I started by gathering detailed information about the issue. I reviewed 
                               the system logs, spoke with hardware engineers and replicated the problem 
                               in a controlled environment to observe its behavior.

    2. Analyze the Causes: Using the data collected, I performed a root cause analysis. I ulitized tools 
                           like oscilloscopes and multimeters to diagnose electrical signals and identified
                           that the issue was related to noise interference affecting the speed control signal.

    3. Brainstorming Solutions: I collaborated with the team to brainstorm potential solutions. We considered
                                several approaches, including improving the shielding of the control signal,
                                updating the software filter algorithms, and adjusting the hardware input.
    
    4. Implement the Solution: After evaluating the pros and cons of each option, we decided to update the 
                               software filter algorithm to better handle noise interferences. I coded the
                               new filter, tested it in isolation, and then intergrated into the system.
    
    5. Review the Results: After implementation, I conducted extensive testing to ensure the issue was 
                           resolved. We ran the bed through various scenarious to confirm the motor speeds 
                           were consitent and reliable. The solution was effective, and the problem did not
                           reoccur. 
    
    This structured approach allowed us to identify and resolve the issue efficiently, ensuring the device
    met safety and performance standards. By involving the team and using a combination of analytical and
    practical methods, we were able to implement a robust solution. 

    In summary, my problem-solving process involves thorough understanding, detailed analysis, collaborative 
    brainstorming, effective implementation, and rigorous review. This approach ensures that I address 
    problems comprehensively and deliver reliable solutions. 

-------------------------------------------------------------------------------------------------------
Q.4 How will you handle pressure?
Ans I handle pressure by staying organized, maintaining a positive attitude, and focusing on solutions rather
    than problems. I believe that pressure is an inevitable part of any challenging job, and it's important to 
    approach it methodically.

    For example, during a critical phase of a project at Jabil, we faced an unexpected issue with the software
    for a hemodialysis machine that needed to be resolved quickly to meet our regulatory deadline. The
    pressure was high as the deadline was non-negotiable and the impact on patients' safetly was significant.

    To handle the situation, I first prioritized tasks by breaking down the problem into smaller, manageable parts. 
    I organized a team meeting to clearly communicate the issue and delegate responsibilities based on each team 
    member's strengths. This ensured that everyone knew their role and could work efficiently.  

-------------------------------------------------------------------------------------------------------
Q.5 Why Cummins?
Ans I am particularly drawn to Cummins because of its reputation as a leader in innovative and sustainable 
    power solutions. The company's commitment to reducing emissions and advancing clean energy technologies
    resonates deeply with my professional and personal values. I am passionate about contributing to a 
    future where power generation is both efficient and environmentally responsible.